# ============================
# 1. Build Stage (Java 25)
# ============================
FROM registry.access.redhat.com/ubi9/openjdk-25:latest AS build
WORKDIR /app

# Maven Caching & Build (wie gehabt)
COPY pom.xml .
RUN --mount=type=cache,target=/root/.m2 mvn -q -DskipTests dependency:go-offline
COPY src ./src
RUN --mount=type=cache,target=/root/.m2 mvn -q -DskipTests compile spring-boot:process-aot package

# JAR extrahieren für Layering
RUN cp target/mirrorservice-0.3.1-SNAPSHOT.jar app.jar && \
    java -Djarmode=tools -jar app.jar extract --layers --launcher --destination extracted

# ============================
# 2. JRE Creation Stage (NEU)
# ============================

# WICHTIG: Umschalten auf root, um Pakete zu installieren
USER root
# Installiere die JMODS, die für jlink zwingend erforderlich sind. Red Hat trennt das, um Platz zu sparen.
# Wenn jlink anweist, Debug-Symbole zu entfernen (--strip-debug), sucht das Tool im Hintergrund 
# nach dem System-Befehl objcopy (ein Teil der binutils), was natürlich nicht als notwendig erachtet wurde.
RUN microdnf install -y java-25-openjdk-jmods binutils && \
    microdnf clean all

# Wir analysieren die extrahierten Layer, um ein minimales JRE zu bauen
RUN jdeps \
    --ignore-missing-deps \
    --print-module-deps \
    --multi-release 25 \
    --recursive \
    --class-path "extracted/dependencies/*:extracted/snapshot-dependencies/*" \
    extracted/application/BOOT-INF/classes > modules.txt

# Erzeuge das Custom JRE
# strip-debug -> keine Local Variable Tables, Line Number Tables, Native Debug Symbols
# strip-native-commands -> kein keytool, rmiregistry, jdb, jhsdb, serialver - breaker!
# compress zip-9 ist der moderne Ersatz für --compress=2
# NoClassDefFoundError: java.beans.PropertyEditorSupport -> java.desktop
# jmx, metrics -> java.management
# GC notifications will not be available -> jdk.management
# load jar files (swagger) -> jdk.zipfs
# needs jlink -> java.instrument
# jpa needs java.sql.Date -> java.sql
# jetty jndi config -> java.naming
# jdk25 warnings -> sun.misc.Unsafe, das von Objenesis/CGLIB -> jdk.unsupported
# org.ietf.jgss.GSSException -> java.security.jgss, java.security.sasl
# Generational ZGC (Z Garbage Collector) setzen
# ExitOnOutOfMemoryError OOM killt den Thread und die JVM beenden.
# UTF-8 only String handling
RUN $JAVA_HOME/bin/jlink \
    --module-path /usr/lib/jvm/java-25/jmods \
    --add-modules java.base,$(cat modules.txt),jdk.crypto.ec,jdk.charsets,java.desktop,java.management,jdk.management,jdk.zipfs,java.instrument,java.sql,java.naming,jdk.unsupported,java.security.jgss,java.security.sasl \
    --strip-debug \
    --no-man-pages \
    --no-header-files \
    --compress zip-9 \
    --add-options "-XX:+UseZGC -XX:+ExitOnOutOfMemoryError -Dfile.encoding=UTF-8" \    
    --output /custom-jre

# Erzeuge die Klassenliste für AppCDS
RUN /custom-jre/bin/java -Djarmode=tools -jar app.jar extract --layers --destination cds-extraction

# Erzeugt das Basis-Archiv für das Custom JRE
RUN /custom-jre/bin/java -Xshare:dump

# CDS Archiv generieren
# 1. Liste der Klassen erstellen (Training)
# WICHTIG: Wir nutzen /custom-jre/bin/java, damit das Archiv zum JRE passt!
# spring.context.exit weist Spring Boot an, den Application Context aufzubauen (damit alle Klassen geladen werden), 
# aber die App sofort danach sauber zu beenden
# Training gegen die entpackten Layer (muss identisch zum Start sein!)
RUN /custom-jre/bin/java -XX:ArchiveClassesAtExit=app.jsa \
         -Dspring.context.exit=onRefresh \
         -Dspring.aot.enabled=true \
         -cp "extracted/dependencies/*:extracted/snapshot-dependencies/*:extracted/application/" \
         org.springframework.boot.loader.launch.JarLauncher || [ -f app.jsa ]
# Hinweis: Das "|| true" ist wichtig, da die App beim Training mangels DB/Config evtl. abbricht, 
# aber das Archiv trotzdem schreibt.

# ============================
# 3. Runtime Stage (Minimales OS)
# ============================
# Wir nutzen hier ubi9-minimal statt der vollen Java-Runtime
#FROM registry.access.redhat.com/ubi9/ubi-minimal:latest
FROM gcr.io/distroless/cc

LABEL org.opencontainers.image.title="Java mirrorservice with Custom JRE" \
      org.opencontainers.image.version="0.0.1-SNAPSHOT"

WORKDIR /app

# Kopiere das Custom JRE aus der Build-Stage
COPY --from=build /custom-jre /opt/jre
ENV PATH="/opt/jre/bin:$PATH"

USER nonroot

# Layer kopieren (wie gehabt)
COPY --from=build --chown=65532:65532 /app/extracted/dependencies/ ./
COPY --from=build --chown=65532:65532 /app/extracted/spring-boot-loader/ ./
COPY --from=build --chown=65532:65532 /app/extracted/snapshot-dependencies/ ./
COPY --from=build --chown=65532:65532 /app/extracted/application/ ./
COPY --from=build --chown=65532:65532 /app/app.jsa /app/app.jsa
COPY --chown=65532:65532 containerconfig/application.properties /app/config/application.properties

EXPOSE 8080

#ENTRYPOINT ["/app/entrypoint.sh"]
ENTRYPOINT [ \
    "/opt/jre/bin/java", \
    "-XX:SharedArchiveFile=/app/app.jsa", \
    "-Dspring.aot.enabled=true", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-XX:MaxRAMPercentage=80", \
    "-XX:InitialRAMPercentage=40", \
    "-XX:+UseZGC", \
    "-XX:+ExitOnOutOfMemoryError", \
    "org.springframework.boot.loader.launch.JarLauncher", \
    "--spring.config.location=file:/app/config/application.properties" \
]