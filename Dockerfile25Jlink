# ============================
# 1. Build Stage (Java 25)
# ============================
FROM registry.access.redhat.com/ubi9/openjdk-25:latest AS build
WORKDIR /app

# Maven Caching & Build (wie gehabt)
COPY pom.xml .
RUN --mount=type=cache,target=/root/.m2 mvn -q -DskipTests dependency:go-offline
COPY src ./src
RUN --mount=type=cache,target=/root/.m2 mvn -q -DskipTests compile spring-boot:process-aot package

# JAR extrahieren für Layering (Layer gemäß src/main/resources/layers.xml):
#   - dependencies, observability-dependencies, spring-boot-loader, snapshot-dependencies, application
# Versionsneutrale Selektion: schließt das Original-JAR (nicht-umgepacktes) aus
RUN JAR=$(ls target/*.jar | grep -v original) && \
    cp "$JAR" app.jar && \
    java -Djarmode=tools -jar app.jar extract --layers --launcher --destination extracted

# ============================
# 2. JRE-Erstellung
# (noch innerhalb der build-Stage – benötigt die extrahierten Layer aus Phase 1)
# ============================

# WICHTIG: Umschalten auf root, um Pakete zu installieren
USER root
# Installiere die JMODS, die für jlink zwingend erforderlich sind. Red Hat trennt das, um Platz zu sparen.
# Wenn jlink anweist, Debug-Symbole zu entfernen (--strip-debug), sucht das Tool im Hintergrund 
# nach dem System-Befehl objcopy (ein Teil der binutils), was natürlich nicht als notwendig erachtet wurde.
RUN microdnf install -y java-25-openjdk-jmods binutils && \
    microdnf clean all

# Wir analysieren die extrahierten Layer, um ein minimales JRE zu bauen
RUN jdeps \
    --ignore-missing-deps \
    --print-module-deps \
    --multi-release 25 \
    --recursive \
    --class-path "extracted/dependencies/*:extracted/observability-dependencies/*:extracted/snapshot-dependencies/*" \
    extracted/application/BOOT-INF/classes > modules.txt

# Erzeuge das Custom JRE
# strip-debug -> keine Local Variable Tables, Line Number Tables, Native Debug Symbols
# strip-native-commands -> kein keytool, rmiregistry, jdb, jhsdb, serialver - breaker!
# compress zip-9 ist der moderne Ersatz für --compress=2
# NoClassDefFoundError: java.beans.PropertyEditorSupport -> java.desktop
# jmx, metrics -> java.management
# GC notifications will not be available -> jdk.management
# load jar files (swagger) -> jdk.zipfs
# needs jlink -> java.instrument
# jpa needs java.sql.Date -> java.sql
# jetty jndi config -> java.naming
# jdk25 warnings -> sun.misc.Unsafe, das von Objenesis/CGLIB -> jdk.unsupported
# org.ietf.jgss.GSSException -> java.security.jgss, java.security.sasl

RUN $JAVA_HOME/bin/jlink \
    --module-path /usr/lib/jvm/java-25/jmods \
    --add-modules java.base,$(cat modules.txt),jdk.crypto.ec,jdk.charsets,java.desktop,java.management,jdk.management,jdk.zipfs,java.instrument,java.sql,java.naming,jdk.unsupported,java.security.jgss,java.security.sasl \
    --strip-debug \
    --no-man-pages \
    --no-header-files \
    --compress zip-9 \
    --output /custom-jre

# Erzeuge die Klassenliste für AppCDS
RUN /custom-jre/bin/java -Djarmode=tools -jar app.jar extract --layers --destination cds-extraction

# Erzeugt das Basis-Archiv für das Custom JRE
RUN /custom-jre/bin/java -Xshare:dump

# CDS Archiv generieren
# 1. Liste der Klassen erstellen (Training)
# WICHTIG: Wir nutzen /custom-jre/bin/java, damit das Archiv zum JRE passt!
# spring.context.exit weist Spring Boot an, den Application Context aufzubauen (damit alle Klassen geladen werden), 
# aber die App sofort danach sauber zu beenden
# Training gegen die entpackten Layer (muss identisch zum Start sein!)
RUN /custom-jre/bin/java -XX:ArchiveClassesAtExit=app.jsa \
         -Dspring.context.exit=onRefresh \
         -Dspring.aot.enabled=true \
         -cp "extracted/dependencies/*:extracted/observability-dependencies/*:extracted/snapshot-dependencies/*:extracted/application/" \
         org.springframework.boot.loader.launch.JarLauncher || [ -f app.jsa ]
# Hinweis: Das "|| [ -f app.jsa ]" ist wichtig, da die App beim Training mangels DB/Config evtl. abbricht,
# aber das Archiv trotzdem schreibt. Der Exit-Code 1 ist nur akzeptabel, wenn app.jsa existiert.

# ============================
# 3. Runtime Stage (Minimales OS)
# ============================
# Wir nutzen hier ubi9-minimal statt der vollen Java-Runtime
#FROM registry.access.redhat.com/ubi9/ubi-minimal:latest
FROM gcr.io/distroless/cc

LABEL org.opencontainers.image.title="Java mirrorservice with Custom JRE" \
      org.opencontainers.image.version="0.3.1-SNAPSHOT"

WORKDIR /app

# Kopiere das Custom JRE aus der Build-Stage
COPY --from=build /custom-jre /opt/jre
ENV PATH="/opt/jre/bin:$PATH"

USER nonroot

# Layer kopieren (Reihenfolge entspricht layers.xml: stabilstes zuerst)
COPY --from=build --chown=65532:65532 /app/extracted/dependencies/ ./
COPY --from=build --chown=65532:65532 /app/extracted/observability-dependencies/ ./
COPY --from=build --chown=65532:65532 /app/extracted/spring-boot-loader/ ./
COPY --from=build --chown=65532:65532 /app/extracted/snapshot-dependencies/ ./
COPY --from=build --chown=65532:65532 /app/extracted/application-resources/ ./
COPY --from=build --chown=65532:65532 /app/extracted/application/ ./
COPY --from=build --chown=65532:65532 /app/app.jsa /app/app.jsa
COPY --chown=65532:65532 containerconfig/application.properties /app/config/application.properties

EXPOSE 8080

# ENTRYPOINT-Parameter:
#   /opt/jre/bin/java
#       Startet die JVM aus dem per jlink erzeugten Custom JRE (kein System-Java)
#
#   -XX:SharedArchiveFile=/app/app.jsa
#       Lädt das AppCDS-Archiv (Class Data Sharing) – verkürzt Startzeit erheblich,
#       da Klassen bereits analysiert & gemappt vorliegen
#
#   -Dspring.aot.enabled=true
#       Aktiviert den AOT-Modus von Spring Boot – nutzt die beim Build vorberechneten
#       Proxies, Reflection-Metadaten und Bean-Definitionen statt Runtime-Analyse
#
#   -Djava.security.egd=file:/dev/./urandom
#       Verhindert Blockierung auf /dev/random im Container (kaum Entropie verfügbar);
#       /dev/./urandom ist der übliche Workaround für die JVM-interne Erkennung
#
#   -XX:MaxRAMPercentage=80
#       Begrenzt den Java-Heap auf 80 % des Container-Speicherlimits (statt fester -Xmx)
#
#   -XX:InitialRAMPercentage=40
#       Reserviert zu Beginn 40 % des Container-Speichers als Heap; reduziert Heap-Expansions
#
#   -XX:+UseZGC
#       Aktiviert den Z Garbage Collector: sehr kurze GC-Pausen (<1 ms), ideal für
#       latenzempfindliche Services; in Java 21+ ist Generational ZGC der Standard
#
#   -XX:+ExitOnOutOfMemoryError
#       Beendet die JVM sofort bei OutOfMemoryError – der Container-Orchestrator
#       (Kubernetes/Docker) kann neu starten; verhindert einen "lebenden Zombie"-Prozess
#
#   -Dfile.encoding=UTF-8
#       Erzwingt UTF-8 als Standard-Zeichensatz; das Custom JRE enthält kein
#       Default-Locale-Setup aus dem OS
#
#   org.springframework.boot.loader.launch.JarLauncher
#       Spring Boot Launcher-Klasse; startet die Anwendung aus den extrahierten
#       Layern (extracted/) statt aus einem einzelnen Fat-JAR
#
#   --spring.config.location=file:/app/config/application.properties
#       Überschreibt den Standard-Konfigurationspfad; Konfiguration liegt als
#       separater Docker-Layer vor (besseres Cache-Verhalten bei Config-Änderungen)
ENTRYPOINT [ \
    "/opt/jre/bin/java", \
    "-XX:SharedArchiveFile=/app/app.jsa", \
    "-Dspring.aot.enabled=true", \
    "-Djava.security.egd=file:/dev/./urandom", \
    "-XX:MaxRAMPercentage=80", \
    "-XX:InitialRAMPercentage=40", \
    "-XX:+UseZGC", \
    "-XX:+ExitOnOutOfMemoryError", \
    "-Dfile.encoding=UTF-8", \
    "org.springframework.boot.loader.launch.JarLauncher", \
    "--spring.config.location=file:/app/config/application.properties" \
]